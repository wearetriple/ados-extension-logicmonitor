import * as crypto from "crypto";
import axios, {
  AxiosHeaders,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
} from "axios";

export class LogicMonitor {
  private baseURL: string;
  private accessID: string | undefined;
  private accessKey: string | undefined;
  private bearerToken: string | undefined;
  private tokenType: string | undefined;
  private axiosClient: AxiosInstance;

  constructor(accountName: string) {
    this.baseURL = `https://${accountName}.logicmonitor.com/santaba/rest`;

    this.axiosClient = axios.create({
      baseURL: this.baseURL,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        "X-Version": "3",
      },
      withCredentials: true,
    });

    // Adding the authorization to all requests
    this.axiosClient.interceptors.request.use(
      (config) => {
        let method = "";
        let url = "";
        if (config.method !== undefined) {
          method = config.method;
        }
        if (config.url !== undefined) {
          url = config.url;
        }

        config.headers["Authorization"] = this.getCredentials(method, config.data, url);
        console.log(config);
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
  }

  /**
   * Set the required Bearer token when using the Bearer token to authenticate.
   * @param bearerToken Bearer generated by Logicmonitor
   */
  public useBearerToken(bearerToken: string) {
    this.bearerToken = bearerToken;
    this.tokenType = "Bearer";
  }

  /**
   * Set the required Access ID and Key when using the LMv1 token to authenticate.
   * @param accessID Access ID generated by Logicmonitor
   * @param accessKey Access Key generated by Logicmonitor
   */
  public useLMVv1Token(accessID: string, accessKey: string) {
    this.accessID = accessID;
    this.accessKey = accessKey;
    this.tokenType = "LMVv1";
  }

  /**
   * Generates a LMv1 token based on a given Access ID and Key.
   * These are generated inside Logicmonitor itself.
   * Due to the fact that each token includes an epoch, you're required.
   * to generate a new token per call you do to the API of Logicmonitor.
   *
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private generateLMv1Token(verb: string, body: string, path: string): string {
    let accessKey = "";
    if (this.accessKey !== undefined) {
      accessKey = this.accessKey;
    }
    let epoch = new Date().getTime();

    let msg = verb + epoch + body + path;
    console.log(msg);
    const signatureHex = crypto
      .createHmac("sha256", accessKey)
      .update(msg)
      .digest("hex");
    const sigBase64 = btoa(signatureHex);
    return this.accessID + ":" + sigBase64 + ":" + epoch;
  }

  /**
   * Generated the token required for API authentication to Logicmonitor.
   * The possible options are either a LMv1 or Bearer token.
   * These should initially be set using either useBearerToken() or useLMVv1Token().
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private getCredentials(verb: string, body: string, path: string): string {
    if (this.tokenType === undefined) {
      throw new Error("No credentials set");
    }

    if (this.tokenType === "LMVv1") {
      let token = this.generateLMv1Token(verb, body, path);
      return "LMv1 " + token;
    }

    if (this.tokenType === "Bearer") {
      if (this.bearerToken !== undefined) {
        return "Bearer " + this.bearerToken;
      } else {
        throw new Error("No bearer token set");
      }
    }
    throw new Error("Failed to get credentials");
  }

  /**
   * Create SDT
   * @param sdt SDT type to post
   * @returns SDT response
   */
  public async postSDT(sdt: AllSDTTypes) {
    const path = `/sdt/sdts`;
    let jsonString = JSON.stringify(sdt);

    this.axiosClient
      .post(path, jsonString)
      .then((res) => {
        console.log("Success: " + res.status, res.data);
        return res.data.id;
      })
      .catch((err) => {
        console.log("Failed: " + err.response.status, err.request._header);
        return undefined;
      });
  }

  /**
   * Delete SDT
   * @param sdt SDT type to post
   * @returns SDT response
   */

  public async deleteSDT(sdtID: string) {
    const verb = "DELETE";
    const path = `/sdt/sdts/${sdtID}`;
    const url = this.baseURL + path;

    const response: AxiosResponse = await axios({
      method: verb,
      url: url,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        "X-Version": "3",
        Authorization: this.getCredentials(verb, "", path),
      },
    });

    if (response.status !== 200) {
      throw new Error(`${response.status}`);
    }

    return response.data as ErrorResponse;
  }

  /**
   * Create a SDT Request
   * @param durationInMinutes Duration of the SDT before it enables again
   * @param sdtType SDT Type
   * @param sensorID Sensor ID
   * @returns Specific SDT request type
   */
  public sdtRequest(
    durationInMinutes: number,
    sdtType: string,
    sensorID: number
  ): BaseSDT {
    const now = Date.now();
    const commonProps: BaseSDT = {
      type: sdtType,
      sdtType: "oneTime",
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      startDateTime: now,
      endDateTime: now + durationInMinutes * 60000,
      comment: "Paused by Azure Devops",
    };

    switch (sdtType) {
      case "WebsiteSDT":
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
      case "WebsiteGroupSDT":
        return { ...commonProps, checkpointId: sensorID } as WebsiteGroupSDT;
      case "ResourceSDT":
        return { ...commonProps, deviceId: sensorID } as ResourceSDT;
      case "ResourceGroupSDT":
        return {
          ...commonProps,
          deviceGroupId: sensorID,
          dataSourceId: 0,
          dataSourceName: "All",
        } as ResourceGroupSDT;
      default:
        // Fallback to WebsiteSDT if an unknown type is provided
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
    }
  }
}
