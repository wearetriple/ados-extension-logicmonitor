import * as crypto from "crypto";

export class LogicMonitor {
  private baseURL: string;
  private accessID: string | undefined;
  private accessKey: string | undefined;
  private bearerToken: string | undefined;
  private tokenType: string | undefined;

  constructor(accountName: string) {
    this.baseURL = `https://${accountName}.logicmonitor.com/santaba/rest`;
  }

  /**
   * Set the required Bearer token when using the Bearer token to authenticate.  
   * @param bearerToken Bearer generated by Logicmonitor
   */
  public useBearerToken(bearerToken: string) {
    this.bearerToken = bearerToken;
    this.tokenType = "Bearer";
  }

  /**
   * Set the required Access ID and Key when using the LMv1 token to authenticate.  
   * @param accessID Access ID generated by Logicmonitor
   * @param accessKey Access Key generated by Logicmonitor
   */
  public useLMVv1Token(accessID: string, accessKey: string) {
    this.accessID = accessID;
    this.accessKey = accessKey;
    this.tokenType = "LMVv1";
  }

  /**
   * Generates a LMv1 token based on a given Access ID and Key.  
   * These are generated inside Logicmonitor itself.  
   * Due to the fact that each token includes an epoch, you're required.  
   * to generate a new token per call you do to the API of Logicmonitor.  
   * 
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private generateLMv1Token(verb: string, body: string, path: string): string {
    let accessKey = "";
    if (this.accessKey !== undefined) {
      accessKey = this.accessKey;
    }
    let epoch = new Date().getTime();

    let msg = verb + epoch + body + path;
    const signatureHex = crypto
      .createHmac("sha256", accessKey)
      .update(msg)
      .digest("hex");
    const sigBase64 = btoa(signatureHex);
    return this.accessID + ":" + sigBase64 + ":" + epoch;
  }

  /**
   * Generated the token required for API authentication to Logicmonitor.  
   * The possible options are either a LMv1 or Bearer token.  
   * These should initially be set using either useBearerToken() or useLMVv1Token().  
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private getCredentials(verb: string, body: string, path: string): string {
    if (this.tokenType === undefined) {
      throw new Error("No credentials set");
    }

    if (this.tokenType === "LMVv1") {
      let token = this.generateLMv1Token(verb, body, path)
      return "LMv1 " + token;
    }

    if (this.tokenType === "bearer") {
      if (this.bearerToken !== undefined) {
        return "Bearer " + this.bearerToken;
      } else {
        throw new Error("No bearer token set");
      }
    }
    throw new Error("Failed to get credentials");
  }

  /**
   * Returns the default headers required when calling the Logicmonitor API.  
   * Including the required Authorization header.  
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private getHeaders(verb: string, body: string, path: string): Headers {
    const headers: Headers = new Headers();
    headers.set("Accept", "application/json");
    headers.set("Content-Type", "application/json");
    headers.set("X-Version", "3");
    headers.set("Authorization", this.getCredentials(verb, body, path));
    return headers;
  }


  /**
   * Post SDT request to Logicmonitor
   * @param sdt SDT type to post
   * @returns SDT response
   */
  public async postSDT(sdt: AllSDTTypes ) {
    let verb = "POST";
    let path = "/sdt/sdts";

    let url = this.baseURL + path;
    let jsonBody = JSON.stringify(sdt);


    const request: RequestInfo = new Request(url, {
      method: verb,
      headers: this.getHeaders(verb, jsonBody, path),
      body: jsonBody,
    });

    const response = await fetch(request);
    if (!response.ok) {
      throw new Error(`${response.status}`);
    }
    return await (response.json() as Promise<AllSDTTypes | ErrorResponse>);
  }

    /**
   * Post SDT request to Logicmonitor
   * @param sdt SDT type to post
   * @returns SDT response
   */
    public async deleteSDT(sdtID: string ) {
      let verb = "DELETE";
      let path = `/sdt/sdts/${sdtID}`;
  
      let url = this.baseURL + path;  
  
      const request: RequestInfo = new Request(url, {
        method: verb,
        headers: this.getHeaders(verb, "", path),
      });
  
      const response = await fetch(request);
      if (!response.ok) {
        throw new Error(`${response.status}`);
      }
      return await (response.json() as Promise<ErrorResponse>);
    }

  /**
   * Create a SDT Request
   * @param durationInMinutes Duration of the SDT before it enables again
   * @param sdtType SDT Type
   * @param sensorID Sensor ID
   * @returns Specific SDT request type
   */
  public sdtRequest(durationInMinutes: number, sdtType: string, sensorID: number): BaseSDT {
    const now = Date.now();
    const commonProps: BaseSDT = {
      type: sdtType,
      sdtType: "oneTime",
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      startDateTime: now,
      endDateTime: now + durationInMinutes * 60000,
      comment: "Paused by Azure Devops",
    };

    switch (sdtType) {
      case "WebsiteSDT":
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
      case "WebsiteGroupSDT":
        return { ...commonProps, checkpointId: sensorID } as WebsiteGroupSDT;
      case "ResourceSDT":
        return { ...commonProps, deviceId: sensorID } as ResourceSDT;
      case "ResourceGroupSDT":
        return { ...commonProps, deviceGroupId: sensorID, dataSourceId: 0, dataSourceName: "All" } as ResourceGroupSDT;
      default:
        // Fallback to WebsiteSDT if an unknown type is provided
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
    }
  }
}

