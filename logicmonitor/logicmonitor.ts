import * as crypto from "crypto";
import axios, { AxiosInstance } from "axios";

export class LogicMonitor {
  private baseURL: string;
  private accessID: string | undefined;
  private accessKey: string | undefined;
  private bearerToken: string | undefined;
  private tokenType: string | undefined;
  private client: AxiosInstance;

  public pauseMessage = "Paused by Azure Devops";

  constructor(accountName: string) {
    this.baseURL = `https://${accountName}.logicmonitor.com/santaba/rest`;

    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        "X-Version": "3",
      },
      withCredentials: true,
    });

    // Adding the authorization to all requests
    this.client.interceptors.request.use(
      (config) => {
        let method = "";
        let url = "";
        if (config.method !== undefined) {
          method = config.method;
        }
        if (config.url !== undefined) {
          url = config.url;
        }

        config.headers["Authorization"] = this.getCredentials( method, config.data, url );
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
  }

  /**
   * Set the required Bearer token when using the Bearer token to authenticate.
   * @param bearerToken Bearer generated by Logicmonitor
   */
  public useBearerToken(bearerToken: string) {
    this.bearerToken = bearerToken;
    this.tokenType = "Bearer";
  }

  /**
   * Set the required Access ID and Key when using the LMv1 token to authenticate.
   * @param accessID Access ID generated by Logicmonitor
   * @param accessKey Access Key generated by Logicmonitor
   */
  public useLMVv1Token(accessID: string, accessKey: string) {
    this.accessID = accessID;
    this.accessKey = accessKey;
    this.tokenType = "LMVv1";
  }

  /**
   * Generates a LMv1 token based on a given Access ID and Key.
   * These are generated inside Logicmonitor itself.
   * Due to the fact that each token includes an epoch, you're required.
   * to generate a new token per call you do to the API of Logicmonitor.
   *
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private generateLMv1Token(
    verb: string,
    body: string,
    path: string,
    epoch?: number
  ): string {
    let accessKey = "";
    if (this.accessKey !== undefined) {
      accessKey = this.accessKey;
    }
    // If no epoch is provided, use the current time
    // Used for testing purposes
    const epochTime = epoch ?? new Date().getTime();
    const requestBody = body ?? "";

    let msg = verb.toUpperCase() + epochTime + requestBody + path;
    const signatureHex = crypto
      .createHmac("sha256", accessKey)
      .update(msg)
      .digest("hex");
    const sigBase64 = btoa(signatureHex);
    return `${this.accessID}:${sigBase64}:${epochTime}`;
  }

  /**
   * Generated the token required for API authentication to Logicmonitor.
   * The possible options are either a LMv1 or Bearer token.
   * These should initially be set using either useBearerToken() or useLMVv1Token().
   * @param verb Method verb used in the call
   * @param body Body content used in the call
   * @param path Path used relative to the logicmonitor default API endpoint
   * @returns Authorization token
   */
  private getCredentials(verb: string, body: string, path: string): string {
    if (this.tokenType === undefined) {
      throw new Error("No credentials set");
    }

    if (this.tokenType === "LMVv1") {
      const token = this.generateLMv1Token(verb, body, path);
      return "LMv1 " + token;
    }

    if (this.tokenType === "Bearer") {
      if (!this.bearerToken) {
        throw new Error("No bearer token set");
      } 
      return `Bearer ${this.bearerToken}`;
    }
    throw new Error("Failed to get credentials");
  }

  /**
   * Create SDT
   * @param sdt SDT type to post
   * @returns SDT response
   */
  public async postSDT(sdt: AllSDTTypes): Promise<AllSDTTypes> {
    const path = `/sdt/sdts`;
    const jsonSdt = JSON.stringify(sdt)
    return await this.client
      .post<AllSDTTypes>(path, jsonSdt)
      .then((res) => {
        let { data } = res
        return data
      })
      .catch((err) => {
        throw new Error("Failed to create SDT: " + err.response.status, err.request._header);
      });
}

  /**
   * Delete SDT
   * @param sdt SDT type to post
   * @returns SDT response
   */

  public async deleteSDT(sdtID: string) {
    const path = `/sdt/sdts/${sdtID}`;

    return this.client
      .delete<AllSDTTypes>(path)
      .then((res) => {
        let { data } = res
        return data;
      })
      .catch((err) => {
        throw new Error("Failed to delete SDT: " + err.response.status, err.request._header);
      });
  }

  /**
   * Get SDT
   * @returns SDT 
   */
  public async getSDT(sensorID: number): Promise<AllSDTTypesList> {
    const path = `/sdt/sdts`;

    return await this.client
      .get<AllSDTTypesList>(path, {
        params: {
          filter: `comment:"${this.pauseMessage} - ${sensorID}"`
        },
      })
      .then((res) => {
        let { data } = res
        return data
      })
      .catch((err) => {
        throw new Error("Failed to get SDT list: " + err.response.status, err.request._header);
      });
  }

  /**
   * Create a SDT Request
   * @param durationInMinutes Duration of the SDT before it enables again
   * @param sdtType SDT Type
   * @param sensorID Sensor ID
   * @returns Specific SDT request type
   */
  public sdtRequest(
    durationInMinutes: number,
    sdtType: string,
    sensorID: number
  ): BaseSDT {
    const now = Date.now();
    const commonProps: BaseSDT = {
      type: sdtType,
      sdtType: "oneTime",
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      startDateTime: now,
      endDateTime: now + durationInMinutes * 60000,
      comment: `${this.pauseMessage} - ${sensorID}`,
    };

    switch (sdtType) {
      case "WebsiteSDT":
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
      case "WebsiteGroupSDT":
        return { ...commonProps, checkpointId: sensorID } as WebsiteGroupSDT;
      case "ResourceSDT":
        return { ...commonProps, deviceId: sensorID } as ResourceSDT;
      case "ResourceGroupSDT":
        return {
          ...commonProps,
          deviceGroupId: sensorID,
          dataSourceId: 0,
          dataSourceName: "All",
        } as ResourceGroupSDT;
      default:
        // Fallback to WebsiteSDT if an unknown type is provided
        return { ...commonProps, websiteId: sensorID } as WebsiteSDT;
    }
  }
}
